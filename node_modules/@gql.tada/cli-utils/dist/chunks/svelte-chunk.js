var e = require("typescript");

var t = require("svelte2tsx");

var r = {
  exports: {}
};

!function(e) {
  var t = ",".charCodeAt(0);
  var r = ";".charCodeAt(0);
  var n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var a = new Uint8Array(64);
  var i = new Uint8Array(128);
  for (var s = 0; s < n.length; s++) {
    var o = n.charCodeAt(s);
    a[s] = o;
    i[o] = s;
  }
  var f = "undefined" != typeof TextDecoder ? new TextDecoder : "undefined" != typeof Buffer ? {
    decode: e => Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString()
  } : {
    decode(e) {
      var t = "";
      for (var r = 0; r < e.length; r++) {
        t += String.fromCharCode(e[r]);
      }
      return t;
    }
  };
  function decode(e) {
    var t = new Int32Array(5);
    var r = [];
    var n = 0;
    do {
      var a = indexOf(e, n);
      var i = [];
      var s = !0;
      var o = 0;
      t[0] = 0;
      for (var f = n; f < a; f++) {
        var l = void 0;
        f = decodeInteger(e, f, t, 0);
        var c = t[0];
        if (c < o) {
          s = !1;
        }
        o = c;
        if (hasMoreVlq(e, f, a)) {
          f = decodeInteger(e, f, t, 1);
          f = decodeInteger(e, f, t, 2);
          if (hasMoreVlq(e, f = decodeInteger(e, f, t, 3), a)) {
            f = decodeInteger(e, f, t, 4);
            l = [ c, t[1], t[2], t[3], t[4] ];
          } else {
            l = [ c, t[1], t[2], t[3] ];
          }
        } else {
          l = [ c ];
        }
        i.push(l);
      }
      if (!s) {
        sort(i);
      }
      r.push(i);
      n = a + 1;
    } while (n <= e.length);
    return r;
  }
  function indexOf(e, t) {
    var r = e.indexOf(";", t);
    return -1 === r ? e.length : r;
  }
  function decodeInteger(e, t, r, n) {
    var a = 0;
    var s = 0;
    var o = 0;
    do {
      var f = e.charCodeAt(t++);
      a |= (31 & (o = i[f])) << s;
      s += 5;
    } while (32 & o);
    var l = 1 & a;
    a >>>= 1;
    if (l) {
      a = -2147483648 | -a;
    }
    r[n] += a;
    return t;
  }
  function hasMoreVlq(e, r, n) {
    if (r >= n) {
      return !1;
    }
    return e.charCodeAt(r) !== t;
  }
  function sort(e) {
    e.sort(sortComparator);
  }
  function sortComparator(e, t) {
    return e[0] - t[0];
  }
  function encode(e) {
    var n = new Int32Array(5);
    var a = 16384;
    var i = a - 36;
    var s = new Uint8Array(a);
    var o = s.subarray(0, i);
    var l = 0;
    var c = "";
    for (var u = 0; u < e.length; u++) {
      var g = e[u];
      if (u > 0) {
        if (l === a) {
          c += f.decode(s);
          l = 0;
        }
        s[l++] = r;
      }
      if (0 === g.length) {
        continue;
      }
      n[0] = 0;
      for (var h = 0; h < g.length; h++) {
        var v = g[h];
        if (l > i) {
          c += f.decode(o);
          s.copyWithin(0, i, l);
          l -= i;
        }
        if (h > 0) {
          s[l++] = t;
        }
        l = encodeInteger(s, l, n, v, 0);
        if (1 === v.length) {
          continue;
        }
        l = encodeInteger(s, l, n, v, 1);
        l = encodeInteger(s, l, n, v, 2);
        l = encodeInteger(s, l, n, v, 3);
        if (4 === v.length) {
          continue;
        }
        l = encodeInteger(s, l, n, v, 4);
      }
    }
    return c + f.decode(s.subarray(0, l));
  }
  function encodeInteger(e, t, r, n, i) {
    var s = n[i];
    var o = s - r[i];
    r[i] = s;
    o = o < 0 ? -o << 1 | 1 : o << 1;
    do {
      var f = 31 & o;
      if ((o >>>= 5) > 0) {
        f |= 32;
      }
      e[t++] = a[f];
    } while (o > 0);
    return t;
  }
  e.decode = decode;
  e.encode = encode;
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
}(r.exports);

var n = r.exports;

class FullTextDocument {
  constructor(e, t, r, n) {
    this._uri = e;
    this._languageId = t;
    this._version = r;
    this._content = n;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(e) {
    if (e) {
      var t = this.offsetAt(e.start);
      var r = this.offsetAt(e.end);
      return this._content.substring(t, r);
    }
    return this._content;
  }
  update(e, t) {
    for (var r of e) {
      if (FullTextDocument.isIncremental(r)) {
        var n = getWellformedRange(r.range);
        var a = this.offsetAt(n.start);
        var i = this.offsetAt(n.end);
        this._content = this._content.substring(0, a) + r.text + this._content.substring(i, this._content.length);
        var s = Math.max(n.start.line, 0);
        var o = Math.max(n.end.line, 0);
        var f = this._lineOffsets;
        var l = computeLineOffsets(r.text, !1, a);
        if (o - s === l.length) {
          for (var c = 0, u = l.length; c < u; c++) {
            f[c + s + 1] = l[c];
          }
        } else if (l.length < 1e4) {
          f.splice(s + 1, o - s, ...l);
        } else {
          this._lineOffsets = f = f.slice(0, s + 1).concat(l, f.slice(o + 1));
        }
        var g = r.text.length - (i - a);
        if (0 !== g) {
          for (var h = s + 1 + l.length, v = f.length; h < v; h++) {
            f[h] = f[h] + g;
          }
        }
      } else if (FullTextDocument.isFull(r)) {
        this._content = r.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = t;
  }
  getLineOffsets() {
    if (void 0 === this._lineOffsets) {
      this._lineOffsets = computeLineOffsets(this._content, !0);
    }
    return this._lineOffsets;
  }
  positionAt(e) {
    e = Math.max(Math.min(e, this._content.length), 0);
    var t = this.getLineOffsets();
    var r = 0, n = t.length;
    if (0 === n) {
      return {
        line: 0,
        character: e
      };
    }
    while (r < n) {
      var a = Math.floor((r + n) / 2);
      if (t[a] > e) {
        n = a;
      } else {
        r = a + 1;
      }
    }
    var i = r - 1;
    return {
      line: i,
      character: e - t[i]
    };
  }
  offsetAt(e) {
    var t = this.getLineOffsets();
    if (e.line >= t.length) {
      return this._content.length;
    } else if (e.line < 0) {
      return 0;
    }
    var r = t[e.line];
    return Math.max(Math.min(r + e.character, e.line + 1 < t.length ? t[e.line + 1] : this._content.length), r);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(e) {
    return null != e && "string" == typeof e.text && void 0 !== e.range && (void 0 === e.rangeLength || "number" == typeof e.rangeLength);
  }
  static isFull(e) {
    return null != e && "string" == typeof e.text && void 0 === e.range && void 0 === e.rangeLength;
  }
}

var a;

!function(e) {
  e.create = function create(e, t, r, n) {
    return new FullTextDocument(e, t, r, n);
  };
  e.update = function update(e, t, r) {
    if (e instanceof FullTextDocument) {
      e.update(t, r);
      return e;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  };
  e.applyEdits = function applyEdits(e, t) {
    var r = e.getText();
    var n = mergeSort(t.map(getWellformedEdit), ((e, t) => {
      var r = e.range.start.line - t.range.start.line;
      if (0 === r) {
        return e.range.start.character - t.range.start.character;
      }
      return r;
    }));
    var a = 0;
    var i = [];
    for (var s of n) {
      var o = e.offsetAt(s.range.start);
      if (o < a) {
        throw new Error("Overlapping edit");
      } else if (o > a) {
        i.push(r.substring(a, o));
      }
      if (s.newText.length) {
        i.push(s.newText);
      }
      a = e.offsetAt(s.range.end);
    }
    i.push(r.substr(a));
    return i.join("");
  };
}(a || (a = {}));

function mergeSort(e, t) {
  if (e.length <= 1) {
    return e;
  }
  var r = e.length / 2 | 0;
  var n = e.slice(0, r);
  var a = e.slice(r);
  mergeSort(n, t);
  mergeSort(a, t);
  var i = 0;
  var s = 0;
  var o = 0;
  while (i < n.length && s < a.length) {
    if (t(n[i], a[s]) <= 0) {
      e[o++] = n[i++];
    } else {
      e[o++] = a[s++];
    }
  }
  while (i < n.length) {
    e[o++] = n[i++];
  }
  while (s < a.length) {
    e[o++] = a[s++];
  }
  return e;
}

function computeLineOffsets(e, t, r = 0) {
  var n = t ? [ r ] : [];
  for (var a = 0; a < e.length; a++) {
    var i = e.charCodeAt(a);
    if (13 === i || 10 === i) {
      if (13 === i && a + 1 < e.length && 10 === e.charCodeAt(a + 1)) {
        a++;
      }
      n.push(r + a + 1);
    }
  }
  return n;
}

function getWellformedRange(e) {
  var t = e.start;
  var r = e.end;
  if (t.line > r.line || t.line === r.line && t.character > r.character) {
    return {
      start: r,
      end: t
    };
  }
  return e;
}

function getWellformedEdit(e) {
  var t = getWellformedRange(e.range);
  if (t !== e.range) {
    return {
      newText: e.newText,
      range: t
    };
  }
  return e;
}

exports.transform = r => {
  var i = r.getFullText();
  var s;
  try {
    s = t.svelte2tsx(i, {
      filename: r.fileName,
      isTsFile: !0,
      emitOnTemplateError: !0,
      mode: "ts"
    });
  } catch (e) {
    return;
  }
  var o = n.decode(s.map.mappings);
  var f = a.create("", "svelte", 0, i);
  var l = a.create("", "typescript", 0, s.code);
  var c = [];
  var u;
  for (var g = 0; g < o.length; g++) {
    for (var h of o[g]) {
      var v = l.offsetAt({
        line: g,
        character: h[0]
      });
      if (u) {
        var d = v - u.genOffset;
        var p = i.substring(u.sourceOffset, u.sourceOffset + d);
        var m = s.code.substring(u.genOffset, u.genOffset + d);
        if (p !== m) {
          d = 0;
          for (var O = 0; O < v - u.genOffset; O++) {
            if (p[O] === m[O]) {
              d = O + 1;
            } else {
              break;
            }
          }
        }
        if (d > 0) {
          var x = c.length ? c[c.length - 1] : void 0;
          if (x && x.generatedOffsets[0] + x.lengths[0] === u.genOffset && x.sourceOffsets[0] + x.lengths[0] === u.sourceOffset) {
            x.lengths[0] += d;
          } else {
            c.push({
              sourceOffsets: [ u.sourceOffset ],
              generatedOffsets: [ u.genOffset ],
              lengths: [ d ],
              data: {
                verification: !0,
                completion: !0,
                semantic: !0,
                navigation: !0,
                structure: !1,
                format: !1
              }
            });
          }
        }
        u = void 0;
      }
      if (void 0 !== h[2] && void 0 !== h[3]) {
        u = {
          genOffset: v,
          sourceOffset: f.offsetAt({
            line: h[2],
            character: h[3]
          })
        };
      }
    }
  }
  return {
    id: "ts",
    languageId: "typescript",
    snapshot: e.ScriptSnapshot.fromString(s.code),
    mappings: c,
    embeddedCodes: []
  };
};
//# sourceMappingURL=svelte-chunk.js.map
