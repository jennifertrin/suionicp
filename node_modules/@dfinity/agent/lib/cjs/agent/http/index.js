"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HttpAgent_instances, _HttpAgent_waterMark, _HttpAgent_queryPipeline, _HttpAgent_updatePipeline, _HttpAgent_subnetKeys, _HttpAgent_verifyQuerySignatures, _HttpAgent_requestAndRetryQuery, _HttpAgent_verifyQueryResponse;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpAgent = exports.IdentityInvalidError = exports.MANAGEMENT_CANISTER_ID = exports.IC_ROOT_KEY = exports.RequestStatusResponseStatus = exports.makeNonce = void 0;
const principal_1 = require("@dfinity/principal");
const errors_1 = require("../../errors");
const auth_1 = require("../../auth");
const cbor = __importStar(require("../../cbor"));
const request_id_1 = require("../../request_id");
const buffer_1 = require("../../utils/buffer");
const transforms_1 = require("./transforms");
const types_1 = require("./types");
const errors_2 = require("./errors");
const canisterStatus_1 = require("../../canisterStatus");
const certificate_1 = require("../../certificate");
const ed25519_1 = require("@noble/curves/ed25519");
const expirableMap_1 = require("../../utils/expirableMap");
const public_key_1 = require("../../public_key");
const leb_1 = require("../../utils/leb");
const observable_1 = require("../../observable");
__exportStar(require("./transforms"), exports);
var types_2 = require("./types");
Object.defineProperty(exports, "makeNonce", { enumerable: true, get: function () { return types_2.makeNonce; } });
var RequestStatusResponseStatus;
(function (RequestStatusResponseStatus) {
    RequestStatusResponseStatus["Received"] = "received";
    RequestStatusResponseStatus["Processing"] = "processing";
    RequestStatusResponseStatus["Replied"] = "replied";
    RequestStatusResponseStatus["Rejected"] = "rejected";
    RequestStatusResponseStatus["Unknown"] = "unknown";
    RequestStatusResponseStatus["Done"] = "done";
})(RequestStatusResponseStatus = exports.RequestStatusResponseStatus || (exports.RequestStatusResponseStatus = {}));
// Default delta for ingress expiry is 5 minutes.
const DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1000;
// Root public key for the IC, encoded as hex
exports.IC_ROOT_KEY = '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814' +
    'c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d968' +
    '5f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484' +
    'b01291091c5f87b98883463f98091a0baaae';
exports.MANAGEMENT_CANISTER_ID = 'aaaaa-aa';
// IC0 domain info
const IC0_DOMAIN = 'ic0.app';
const IC0_SUB_DOMAIN = '.ic0.app';
const ICP0_DOMAIN = 'icp0.io';
const ICP0_SUB_DOMAIN = '.icp0.io';
const ICP_API_DOMAIN = 'icp-api.io';
const ICP_API_SUB_DOMAIN = '.icp-api.io';
class HttpDefaultFetchError extends errors_1.AgentError {
    constructor(message) {
        super(message);
        this.message = message;
    }
}
class IdentityInvalidError extends errors_1.AgentError {
    constructor(message) {
        super(message);
        this.message = message;
    }
}
exports.IdentityInvalidError = IdentityInvalidError;
function getDefaultFetch() {
    let defaultFetch;
    if (typeof window !== 'undefined') {
        // Browser context
        if (window.fetch) {
            defaultFetch = window.fetch.bind(window);
        }
        else {
            throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.');
        }
    }
    else if (typeof global !== 'undefined') {
        // Node context
        if (global.fetch) {
            defaultFetch = global.fetch.bind(global);
        }
        else {
            throw new HttpDefaultFetchError('Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.');
        }
    }
    else if (typeof self !== 'undefined') {
        if (self.fetch) {
            defaultFetch = self.fetch.bind(self);
        }
    }
    if (defaultFetch) {
        return defaultFetch;
    }
    throw new HttpDefaultFetchError('Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.');
}
// A HTTP agent allows users to interact with a client of the internet computer
// using the available methods. It exposes an API that closely follows the
// public view of the internet computer, and is not intended to be exposed
// directly to the majority of users due to its low-level interface.
//
// There is a pipeline to apply transformations to the request before sending
// it to the client. This is to decouple signature, nonce generation and
// other computations so that this class can stay as simple as possible while
// allowing extensions.
class HttpAgent {
    constructor(options = {}) {
        var _a;
        _HttpAgent_instances.add(this);
        this.rootKey = (0, buffer_1.fromHex)(exports.IC_ROOT_KEY);
        this._timeDiffMsecs = 0;
        this._rootKeyFetched = false;
        this._isAgent = true;
        // The UTC time in milliseconds when the latest request was made
        _HttpAgent_waterMark.set(this, 0);
        this.log = new observable_1.ObservableLog();
        _HttpAgent_queryPipeline.set(this, []);
        _HttpAgent_updatePipeline.set(this, []);
        _HttpAgent_subnetKeys.set(this, new expirableMap_1.ExpirableMap({
            expirationTime: 5 * 60 * 1000, // 5 minutes
        }));
        _HttpAgent_verifyQuerySignatures.set(this, true);
        /**
         * See https://internetcomputer.org/docs/current/references/ic-interface-spec/#http-query for details on validation
         * @param queryResponse - The response from the query
         * @param subnetStatus - The subnet status, including all node keys
         * @returns ApiQueryResponse
         */
        _HttpAgent_verifyQueryResponse.set(this, (queryResponse, subnetStatus) => {
            if (__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f") === false) {
                // This should not be called if the user has disabled verification
                return queryResponse;
            }
            if (!subnetStatus) {
                throw new certificate_1.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');
            }
            const { status, signatures = [], requestId } = queryResponse;
            const domainSeparator = new TextEncoder().encode('\x0Bic-response');
            for (const sig of signatures) {
                const { timestamp, identity } = sig;
                const nodeId = principal_1.Principal.fromUint8Array(identity).toText();
                let hash;
                // Hash is constructed differently depending on the status
                if (status === 'replied') {
                    const { reply } = queryResponse;
                    hash = (0, request_id_1.hashOfMap)({
                        status: status,
                        reply: reply,
                        timestamp: BigInt(timestamp),
                        request_id: requestId,
                    });
                }
                else if (status === 'rejected') {
                    const { reject_code, reject_message, error_code } = queryResponse;
                    hash = (0, request_id_1.hashOfMap)({
                        status: status,
                        reject_code: reject_code,
                        reject_message: reject_message,
                        error_code: error_code,
                        timestamp: BigInt(timestamp),
                        request_id: requestId,
                    });
                }
                else {
                    throw new Error(`Unknown status: ${status}`);
                }
                const separatorWithHash = (0, buffer_1.concat)(domainSeparator, new Uint8Array(hash));
                // FIX: check for match without verifying N times
                const pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);
                if (!pubKey) {
                    throw new certificate_1.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');
                }
                const rawKey = public_key_1.Ed25519PublicKey.fromDer(pubKey).rawKey;
                const valid = ed25519_1.ed25519.verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));
                if (valid)
                    return queryResponse;
                throw new certificate_1.CertificateVerificationError(`Invalid signature from replica ${nodeId} signed query.`);
            }
            return queryResponse;
        });
        if (options.source) {
            if (!(options.source instanceof HttpAgent)) {
                throw new Error("An Agent's source can only be another HttpAgent");
            }
            this._identity = options.source._identity;
            this._fetch = options.source._fetch;
            this._host = options.source._host;
            this._credentials = options.source._credentials;
        }
        else {
            this._fetch = options.fetch || getDefaultFetch() || fetch.bind(global);
            this._fetchOptions = options.fetchOptions;
            this._callOptions = options.callOptions;
        }
        if (options.host !== undefined) {
            if (!options.host.match(/^[a-z]+:/) && typeof window !== 'undefined') {
                this._host = new URL(window.location.protocol + '//' + options.host);
            }
            else {
                this._host = new URL(options.host);
            }
        }
        else if (options.source !== undefined) {
            // Safe to ignore here.
            this._host = options.source._host;
        }
        else {
            const location = typeof window !== 'undefined' ? window.location : undefined;
            if (!location) {
                this._host = new URL('https://icp-api.io');
                this.log.warn('Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.');
            }
            // Mainnet, local, and remote environments will have the api route available
            const knownHosts = ['ic0.app', 'icp0.io', '127.0.0.1', 'localhost'];
            const remoteHosts = ['.github.dev', '.gitpod.io'];
            const hostname = location === null || location === void 0 ? void 0 : location.hostname;
            let knownHost;
            if (hostname && typeof hostname === 'string') {
                if (remoteHosts.some(host => hostname.endsWith(host))) {
                    knownHost = hostname;
                }
                else {
                    knownHost = knownHosts.find(host => hostname.endsWith(host));
                }
            }
            if (location && knownHost) {
                // If the user is on a boundary-node provided host, we can use the same host for the agent
                this._host = new URL(`${location.protocol}//${knownHost}${location.port ? ':' + location.port : ''}`);
            }
            else {
                this._host = new URL('https://icp-api.io');
                this.log.warn('Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.');
            }
        }
        if (options.verifyQuerySignatures !== undefined) {
            __classPrivateFieldSet(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, "f");
        }
        // Default is 3
        this._retryTimes = (_a = options.retryTimes) !== null && _a !== void 0 ? _a : 3;
        // Rewrite to avoid redirects
        if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {
            this._host.hostname = IC0_DOMAIN;
        }
        else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN)) {
            this._host.hostname = ICP0_DOMAIN;
        }
        else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {
            this._host.hostname = ICP_API_DOMAIN;
        }
        if (options.credentials) {
            const { name, password } = options.credentials;
            this._credentials = `${name}${password ? ':' + password : ''}`;
        }
        this._identity = Promise.resolve(options.identity || new auth_1.AnonymousIdentity());
        // Add a nonce transform to ensure calls are unique
        this.addTransform('update', (0, transforms_1.makeNonceTransform)(types_1.makeNonce));
        if (options.useQueryNonces) {
            this.addTransform('query', (0, transforms_1.makeNonceTransform)(types_1.makeNonce));
        }
        if (options.logToConsole) {
            this.log.subscribe(log => {
                if (log.level === 'error') {
                    console.error(log.message);
                }
                else if (log.level === 'warn') {
                    console.warn(log.message);
                }
                else {
                    console.log(log.message);
                }
            });
        }
    }
    get waterMark() {
        return __classPrivateFieldGet(this, _HttpAgent_waterMark, "f");
    }
    isLocal() {
        const hostname = this._host.hostname;
        return hostname === '127.0.0.1' || hostname.endsWith('127.0.0.1');
    }
    addTransform(type, fn, priority = fn.priority || 0) {
        if (type === 'update') {
            // Keep the pipeline sorted at all time, by priority.
            const i = __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").findIndex(x => (x.priority || 0) < priority);
            __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f").length, 0, Object.assign(fn, { priority }));
        }
        else if (type === 'query') {
            // Keep the pipeline sorted at all time, by priority.
            const i = __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").findIndex(x => (x.priority || 0) < priority);
            __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").splice(i >= 0 ? i : __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f").length, 0, Object.assign(fn, { priority }));
        }
    }
    async getPrincipal() {
        if (!this._identity) {
            throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
        }
        return (await this._identity).getPrincipal();
    }
    async call(canisterId, options, identity) {
        const id = await (identity !== undefined ? await identity : await this._identity);
        if (!id) {
            throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
        }
        const canister = principal_1.Principal.from(canisterId);
        const ecid = options.effectiveCanisterId
            ? principal_1.Principal.from(options.effectiveCanisterId)
            : canister;
        const sender = id.getPrincipal() || principal_1.Principal.anonymous();
        let ingress_expiry = new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);
        // If the value is off by more than 30 seconds, reconcile system time with the network
        if (Math.abs(this._timeDiffMsecs) > 1000 * 30) {
            ingress_expiry = new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);
        }
        const submit = {
            request_type: types_1.SubmitRequestType.Call,
            canister_id: canister,
            method_name: options.methodName,
            arg: options.arg,
            sender,
            ingress_expiry,
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let transformedRequest = (await this._transform({
            request: {
                body: null,
                method: 'POST',
                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
            },
            endpoint: "call" /* Endpoint.Call */,
            body: submit,
        }));
        // Apply transform for identity.
        transformedRequest = await id.transformRequest(transformedRequest);
        const body = cbor.encode(transformedRequest.body);
        this.log(`fetching "/api/v2/canister/${ecid.toText()}/call" with request:`, transformedRequest);
        // Run both in parallel. The fetch is quite expensive, so we have plenty of time to
        // calculate the requestId locally.
        const request = this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign(Object.assign({}, this._callOptions), transformedRequest.request), { body })));
        const [response, requestId] = await Promise.all([request, (0, request_id_1.requestIdOf)(submit)]);
        const responseBuffer = await response.arrayBuffer();
        const responseBody = (response.status === 200 && responseBuffer.byteLength > 0 ? cbor.decode(responseBuffer) : null);
        return {
            requestId,
            response: {
                ok: response.ok,
                status: response.status,
                statusText: response.statusText,
                body: responseBody,
                headers: (0, transforms_1.httpHeadersTransform)(response.headers),
            },
        };
    }
    async _requestAndRetry(request, tries = 0) {
        let response;
        try {
            response = await request();
        }
        catch (error) {
            if (this._retryTimes > tries) {
                this.log.warn(`Caught exception while attempting to make request:\n` +
                    `  ${error}\n` +
                    `  Retrying request.`);
                return await this._requestAndRetry(request, tries + 1);
            }
            throw error;
        }
        if (response.ok) {
            return response;
        }
        const responseText = await response.clone().text();
        const errorMessage = `Server returned an error:\n` +
            `  Code: ${response.status} (${response.statusText})\n` +
            `  Body: ${responseText}\n`;
        if (this._retryTimes > tries) {
            this.log.warn(errorMessage + `  Retrying request.`);
            return await this._requestAndRetry(request, tries + 1);
        }
        throw new errors_2.AgentHTTPResponseError(errorMessage, {
            ok: response.ok,
            status: response.status,
            statusText: response.statusText,
            headers: (0, transforms_1.httpHeadersTransform)(response.headers),
        });
    }
    async query(canisterId, fields, identity) {
        const ecid = fields.effectiveCanisterId
            ? principal_1.Principal.from(fields.effectiveCanisterId)
            : principal_1.Principal.from(canisterId);
        this.log(`ecid ${ecid.toString()}`);
        this.log(`canisterId ${canisterId.toString()}`);
        const makeQuery = async () => {
            const id = await (identity !== undefined ? await identity : await this._identity);
            if (!id) {
                throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
            }
            const canister = principal_1.Principal.from(canisterId);
            const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || principal_1.Principal.anonymous();
            const request = {
                request_type: "query" /* ReadRequestType.Query */,
                canister_id: canister,
                method_name: fields.methodName,
                arg: fields.arg,
                sender,
                ingress_expiry: new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
            };
            const requestId = await (0, request_id_1.requestIdOf)(request);
            // TODO: remove this any. This can be a Signed or UnSigned request.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            let transformedRequest = await this._transform({
                request: {
                    method: 'POST',
                    headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
                },
                endpoint: "read" /* Endpoint.Query */,
                body: request,
            });
            // Apply transform for identity.
            transformedRequest = (await (id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest)));
            const body = cbor.encode(transformedRequest.body);
            const args = {
                canister: canister.toText(),
                ecid,
                transformedRequest,
                body,
                requestId,
            };
            return await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetryQuery).call(this, args);
        };
        const getSubnetStatus = async () => {
            if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f")) {
                return undefined;
            }
            const subnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").get(ecid.toString());
            if (subnetStatus) {
                return subnetStatus;
            }
            await this.fetchSubnetKeys(ecid.toString());
            return __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").get(ecid.toString());
        };
        // Attempt to make the query i=retryTimes times
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        // Make query and fetch subnet keys in parallel
        const [query, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);
        this.log('Query response:', query);
        // Skip verification if the user has disabled it
        if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f")) {
            return query;
        }
        try {
            return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, "f").call(this, query, subnetStatus);
        }
        catch (_) {
            // In case the node signatures have changed, refresh the subnet keys and try again
            this.log.warn('Query response verification failed. Retrying with fresh subnet keys.');
            __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").delete(canisterId.toString());
            await this.fetchSubnetKeys(ecid.toString());
            const updatedSubnetStatus = __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").get(canisterId.toString());
            if (!updatedSubnetStatus) {
                throw new certificate_1.CertificateVerificationError('Invalid signature from replica signed query: no matching node key found.');
            }
            return __classPrivateFieldGet(this, _HttpAgent_verifyQueryResponse, "f").call(this, query, updatedSubnetStatus);
        }
    }
    async createReadStateRequest(fields, identity) {
        const id = await (identity !== undefined ? await identity : await this._identity);
        if (!id) {
            throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
        }
        const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || principal_1.Principal.anonymous();
        // TODO: remove this any. This can be a Signed or UnSigned request.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const transformedRequest = await this._transform({
            request: {
                method: 'POST',
                headers: Object.assign({ 'Content-Type': 'application/cbor' }, (this._credentials ? { Authorization: 'Basic ' + btoa(this._credentials) } : {})),
            },
            endpoint: "read_state" /* Endpoint.ReadState */,
            body: {
                request_type: "read_state" /* ReadRequestType.ReadState */,
                paths: fields.paths,
                sender,
                ingress_expiry: new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
            },
        });
        // Apply transform for identity.
        return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);
    }
    async readState(canisterId, fields, identity, 
    // eslint-disable-next-line
    request) {
        const canister = typeof canisterId === 'string' ? principal_1.Principal.fromText(canisterId) : canisterId;
        const transformedRequest = request !== null && request !== void 0 ? request : (await this.createReadStateRequest(fields, identity));
        const body = cbor.encode(transformedRequest.body);
        this.log(`fetching "/api/v2/canister/${canister}/read_state" with request:`, transformedRequest);
        // TODO - https://dfinity.atlassian.net/browse/SDK-1092
        const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
        if (!response.ok) {
            throw new Error(`Server returned an error:\n` +
                `  Code: ${response.status} (${response.statusText})\n` +
                `  Body: ${await response.text()}\n`);
        }
        const decodedResponse = cbor.decode(await response.arrayBuffer());
        this.log('Read state response:', decodedResponse);
        const parsedTime = await this.parseTimeFromResponse(decodedResponse);
        if (parsedTime > 0) {
            this.log('Read state response time:', parsedTime);
            __classPrivateFieldSet(this, _HttpAgent_waterMark, parsedTime, "f");
        }
        return decodedResponse;
    }
    async parseTimeFromResponse(response) {
        let tree;
        if (response.certificate) {
            const decoded = cbor.decode(response.certificate);
            if (decoded && 'tree' in decoded) {
                tree = decoded.tree;
            }
            else {
                throw new Error('Could not decode time from response');
            }
            const timeLookup = (0, certificate_1.lookup_path)(['time'], tree);
            if (!timeLookup) {
                throw new Error('Time was not found in the response or was not in its expected format.');
            }
            if (!(timeLookup instanceof ArrayBuffer) && !ArrayBuffer.isView(timeLookup)) {
                throw new Error('Time was not found in the response or was not in its expected format.');
            }
            const date = (0, leb_1.decodeTime)((0, buffer_1.bufFromBufLike)(timeLookup));
            this.log('Time from response:', date);
            this.log('Time from response in milliseconds:', Number(date));
            return Number(date);
        }
        else {
            this.log.warn('No certificate found in response');
        }
        return 0;
    }
    /**
     * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request
     * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default
     */
    async syncTime(canisterId) {
        const CanisterStatus = await Promise.resolve().then(() => __importStar(require('../../canisterStatus')));
        const callTime = Date.now();
        try {
            if (!canisterId) {
                this.log('Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai');
            }
            const status = await CanisterStatus.request({
                // Fall back with canisterId of the ICP Ledger
                canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : principal_1.Principal.from('ryjl3-tyaaa-aaaaa-aaaba-cai'),
                agent: this,
                paths: ['time'],
            });
            const replicaTime = status.get('time');
            if (replicaTime) {
                this._timeDiffMsecs = Number(replicaTime) - Number(callTime);
            }
        }
        catch (error) {
            this.log.error('Caught exception while attempting to sync time', error);
        }
    }
    async status() {
        const headers = this._credentials
            ? {
                Authorization: 'Basic ' + btoa(this._credentials),
            }
            : {};
        this.log(`fetching "/api/v2/status"`);
        const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/status`, this._host), Object.assign({ headers }, this._fetchOptions)));
        return cbor.decode(await response.arrayBuffer());
    }
    async fetchRootKey() {
        if (!this._rootKeyFetched) {
            // Hex-encoded version of the replica root key
            this.rootKey = (await this.status()).root_key;
            this._rootKeyFetched = true;
        }
        return this.rootKey;
    }
    invalidateIdentity() {
        this._identity = null;
    }
    replaceIdentity(identity) {
        this._identity = Promise.resolve(identity);
    }
    async fetchSubnetKeys(canisterId) {
        const effectiveCanisterId = principal_1.Principal.from(canisterId);
        const response = await (0, canisterStatus_1.request)({
            canisterId: effectiveCanisterId,
            paths: ['subnet'],
            agent: this,
        });
        const subnetResponse = response.get('subnet');
        if (subnetResponse && typeof subnetResponse === 'object' && 'nodeKeys' in subnetResponse) {
            __classPrivateFieldGet(this, _HttpAgent_subnetKeys, "f").set(effectiveCanisterId.toText(), subnetResponse);
            return subnetResponse;
        }
        // If the subnet status is not returned, return undefined
        return undefined;
    }
    _transform(request) {
        let p = Promise.resolve(request);
        if (request.endpoint === "call" /* Endpoint.Call */) {
            for (const fn of __classPrivateFieldGet(this, _HttpAgent_updatePipeline, "f")) {
                p = p.then(r => fn(r).then(r2 => r2 || r));
            }
        }
        else {
            for (const fn of __classPrivateFieldGet(this, _HttpAgent_queryPipeline, "f")) {
                p = p.then(r => fn(r).then(r2 => r2 || r));
            }
        }
        return p;
    }
}
exports.HttpAgent = HttpAgent;
_HttpAgent_waterMark = new WeakMap(), _HttpAgent_queryPipeline = new WeakMap(), _HttpAgent_updatePipeline = new WeakMap(), _HttpAgent_subnetKeys = new WeakMap(), _HttpAgent_verifyQuerySignatures = new WeakMap(), _HttpAgent_verifyQueryResponse = new WeakMap(), _HttpAgent_instances = new WeakSet(), _HttpAgent_requestAndRetryQuery = async function _HttpAgent_requestAndRetryQuery(args, tries = 0) {
    var _a, _b;
    const { ecid, transformedRequest, body, requestId } = args;
    let response;
    // Make the request and retry if it throws an error
    try {
        const fetchResponse = await this._fetch('' + new URL(`/api/v2/canister/${ecid.toString()}/query`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body }));
        if (fetchResponse.status === 200) {
            const queryResponse = cbor.decode(await fetchResponse.arrayBuffer());
            response = Object.assign(Object.assign({}, queryResponse), { httpDetails: {
                    ok: fetchResponse.ok,
                    status: fetchResponse.status,
                    statusText: fetchResponse.statusText,
                    headers: (0, transforms_1.httpHeadersTransform)(fetchResponse.headers),
                }, requestId });
        }
        else {
            throw new errors_2.AgentHTTPResponseError(`Server returned an error:\n` +
                `  Code: ${fetchResponse.status} (${fetchResponse.statusText})\n` +
                `  Body: ${await fetchResponse.text()}\n`, {
                ok: fetchResponse.ok,
                status: fetchResponse.status,
                statusText: fetchResponse.statusText,
                headers: (0, transforms_1.httpHeadersTransform)(fetchResponse.headers),
            });
        }
    }
    catch (error) {
        if (tries < this._retryTimes) {
            this.log.warn(`Caught exception while attempting to make query:\n` +
                `  ${error}\n` +
                `  Retrying query.`);
            return await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetryQuery).call(this, args, tries + 1);
        }
        throw error;
    }
    const timestamp = (_b = (_a = response.signatures) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.timestamp;
    // Skip watermark verification if the user has set verifyQuerySignatures to false
    if (!__classPrivateFieldGet(this, _HttpAgent_verifyQuerySignatures, "f")) {
        return response;
    }
    if (!timestamp) {
        throw new Error('Timestamp not found in query response. This suggests a malformed or malicious response.');
    }
    // Convert the timestamp to milliseconds
    const timeStampInMs = Number(BigInt(timestamp) / BigInt(1000000));
    this.log('watermark and timestamp', {
        waterMark: this.waterMark,
        timestamp: timeStampInMs,
    });
    // If the timestamp is less than the watermark, retry the request up to the retry limit
    if (Number(this.waterMark) > timeStampInMs) {
        const error = new errors_1.AgentError('Timestamp is below the watermark. Retrying query.');
        this.log.error('Timestamp is below', error, {
            timestamp,
            waterMark: this.waterMark,
        });
        if (tries < this._retryTimes) {
            return await __classPrivateFieldGet(this, _HttpAgent_instances, "m", _HttpAgent_requestAndRetryQuery).call(this, args, tries + 1);
        }
        {
            throw new errors_1.AgentError(`Timestamp failed to pass the watermark after retrying the configured ${this._retryTimes} times. We cannot guarantee the integrity of the response since it could be a replay attack.`);
        }
    }
    return response;
};
//# sourceMappingURL=index.js.map